

ARC：

        只能管理OC 对象， 不能管理通过malloc申请的内存



        常用规则：

        不能调用跟引用计数相关的方法（retain,release,autorelease,retainCount,也不能使用这些函数的selecter（例如@selecter(retain)））
        ARC中禁止使用NAAutoReleasePool,而使用新语法@autoreleasepool来管理自动释放池
        手动管理内存情况：
        id pool=[[NSAutoreleasePool alloc] init]

            /* 一些操作
              不可使用break、return、goto等，否则有可能造成对象无法被成功释放*/

        [pool release]

        新语法：
        @autoreleasepool{

            /*一些操作
              可以使用break、return、goto等，在运行到@autoreleasepool 块外的时候才进行对象释放*/

        }

        @autoreleasepool在非ARC模式下也能使用，并且使用@autoreleasepool比使用NSAutoReleasePool性能更好，效率更高，所以无论是否使用ARC都推荐使用这种新语法
        


        在ARC中，未指定初始值的变量（包括局部变量）都会被初始化为nil，但是对于_autoreleasing和_unsafe_unretained修饰的变量来说，初始值是未定的
        而对象以外的变量的初值和以前是一样的




        方法族：《Object-C编程全解》P91

        使用名称中包含 new、copy、mutableCopy、alloc、init、retain这些方法是就会获取这个对象的所有权，只有使用release或autorelease才能释放这个对象的所有权
        这些规定被叫做所有权策略，即对象实例该由谁释放，由编程逻辑决定

        由于ARC允许混合链接手动内存管理和自动内存管理的代码，所以针对到底哪个方法同对象的生成和复制相关，不能仅凭方法名区分，而需要定义能够让编译器明确区分的方法，
        同对象生成相关的方法集合叫做方法族


        一个方法要属于某个方法族，需满足返回值和方法的类别方面的要求（具体？？为对应对象类？），也需满足以下命名规则
        1、选择器同方法族名相同（开头的_可以忽略）
       _1、或选择器的名字由方法族名加上非小写字母开头的字符串构成

            目前一共定义了5个方法族：

            alloc方法族 
            copy方法族 
            mutableCopy方法族
            new方法族
                以上4种表示调用者对被创建的对象拥有所有权，返回的对象必须是可以被retain的
                可以是类方法也可以是实例方法，需要将对象所有权返回给调用端，由调用的release生成的对象，
                而如果你想有调用端release一个方法返回的对象，而这个方法的名字却不以上述关键字开头，ARC可能不会释放这个对象， 而造成内存泄漏

            init方法族
                必须被定义为实例方法，一定要返回id类型或父子类的指针

必须要严格遵守内存管理相关的函数命名规则，例如给一个换行的方法命名为newLine可能造成误释放


        
        ARC中的dealloc
        ARC中对象被释放的时候，对象的dealloc函数也会被调用，与手动管理不同的是，要被释放的对象呗另一个对象保持的情况下，ARC会自动进行释放，因此不需要做任何处理（手动内存管理需要执行release让引用计数减1 ）
        ARC中也不能手动调用dealloc方法（包括@selecter（dealloc）等隐式调用），手动内存管理中是不能显示调用dealloc方法，除非是父类的dealloc
        ARC有效时不允许调用父类的dealloc，尽管可以创建一个定制的dealloc方法来释放资源而不是实例变量（实例变量系统会自动释放），
        但也不要调用[super dealloc]，否则会出现编译错误，因为编译器会自动去处理这些事情


        启用ARC编译代码时，不能使用gcc，而要使用clang，同时编译选项中需加上-fobjc-arc,而使用-fno-objc-are明确告诉编译器不想使用ARC


        基本注意事项：P94


        反向指针，只通过指针指向，不拥有所有权的变量，和拥有所有权的实例变量在内存方面的处理截然不同，处理不当就会造成内存泄漏



弱引用：
        ARC中为了解决循环引用，引入的类型，能够引用对象，但不会成为对象的所有者，不影响对象本身的回收
        通过存储一个指向对象的指针创建，且不保存对象，OC 中使用_ _weak修饰符定义

        弱引用情况下，对变量赋值还是解除引用变量的引用计数都不会发生变化，强弱引用都会被隐式初始化为nil

        弱引用会在其指向的实例对象被释放后自动变成nil，使弱引用不会变成野指针（弱引用的自动nil化功能）

生命周期修饰符：（所有权修饰符）

        用于修饰指针类型变量的修饰符
        共4种：
        strong、__weak、autoreleasing、__unsafe_unretained


        
对象之间引用关系的基本原则：

        使用ARC时应该尽量保证对象之间的关系呈树形结构，这样，当一个对象被释放的时候，这个对象引用的对象也会被自然的释放掉
        在使用反向指针指向父节点，或者两个对象之间相互引用，进行跨越子树间的引用等时，容易产生循环引用，此时可以使用弱引用，或通过手动给一方赋值nil，打破循环引用


__unsafe_unretained
        未初始化的情况下，其变量的初始值不定，释放后变量的指向也是不定的，ARC中不会管理这种类型的变量，所以它不安全在有可能变成野指针
        使用__unsafe_unretained所修饰的变量称为 非nil化的弱指针，它不会保持赋值的对象，也不会在赋值对象在释放后被自动设置为nil，所以当它所指向的内存区域被释放了，这就是一个野指针了
        将生成的对象直接赋值给__unsafe_unretained类型对象时，也会导致新生成的对象被直接释放掉



在手动管理内存是有可能在赋值时没对变量进行retain操作，这就相当于在ARC 中用_weak,__unsafe_unretained修饰了变量的行为，这种代码迁移到ARC环境一定要小心其所有权问题



        在使用ARC的程序中，需要使用__bridge修饰符来实现id 类型与 void* 类型的相互转换，ARC可以管理OC 对象，而Core Fundation类型对象不在ARC管理范畴内，
        而IOS中 主要由这两种对象组成，所以当转换这两种类型时（有/没有 ARC管理），需要告诉编译器怎样处理对象的所有权（更太多详情参考《Objective-c编程全解》附录B）







        