id obj;

消息表达式 ：[obj msg]// obj 接收者  msg 消息
   
    可作为变量嵌套在语句中，或单独执行返回void
    允许嵌套
    例：element=table[[obj count]]//内层【】 为消息表达式修饰符，外层为数组修饰符，使用【obj count】 的结果作为table[] 数组的下标
    msg位置的参数被称为消息关键字，其末尾有“：”时，表示消息带有参数，“：”后紧跟着的就是实参，可以是变量，也可以是消息表达式
    例：[doc isSameDirectory:[info objectAtIndex:++num]];
    多参消息：
    [方法名 关键字1：a 关键字2：b 关键字3：c]  或 [方法名：a:b:c]
    例：[ manager fixExistsAtPath:dirname isDirectoty:&isdir]; 或[view lineTo:1.1:(y+1.0)];



消息选择器：消息名（选择器，方法）（对应消息表达式中msg位置？）(函数名？参数名？cell=[albumview cellAtRow:i column:j];)

    带有参数的消息选择器要包含“：”
    例：copy 和copy：是两个不同的选择器
    多参情况：cellAtRow: column:
    由多个消息关键字组成的选择器，关键字的顺序不能错，否则是完全不同的选择器



变量：

    同C一样，仅声明不会为变量赋初值
    OC通过向类发送消息来创建一个对象
    例：[类名 alloc]//alloc执行完同C一样为申请到存储空间，仍需调用初始化方法
    Cocoa中的初始化方法通常为init或由init开头的函数。
    例：[[类名 alloc] init] //完整地创建并初始化Cocoa中的某个类//通常嵌套调用alloc和init来生成一个对象
    tip:对象生成后知需调用一次初始化方法，init并没有reset功能,使变量的值恢复初始值需要专用函数，另外，有的类不是用alloc方法而使用其他方法生成对象，
    有的类也可能会返回一个初始化好的对象（OC中哪个系的类会？还是在自己实现中灵活运用？）



类的定义:(interface和implementat是分开的)（OC中的类由接口和实现组成？）

    语法：
    @interface 类名：父类名
    {
        实例变量的定义；
    }
    方法声明；
    @end

    OC中类接口的声明以@interface开头，以@end结尾，所有的OC编译指令都以@ 开头，以区分C中的字符串（关键字？）



方法声明：

    -(id)delegate; // "-"表示是实例方法，返回值使用“（）”括起来
    -(id)cellAtRow:(int)row column:(int) col;//参数的类型指定用“()”括起来放在参数之前，row和col是参数
    -(void)setAutoPlay(BOOL)falg;//无返回值时使用void表示



返回值：

    可以省略方法返回值，编译器默认增加id类型的返回值（不推荐，不清晰）
    tips:在C中省略返回值会默认增加int类型的返回值，但存在争议，有可以能以后会被废除



静态变量：

    在函数或类方法范围外定义的变量，及制定了static的变量，生命周期为从程序开始执行到结束。



根类：

        NSObject是Cocoa环境下的根类（NSProxy听说也是，Objective-C编程全解，19章）



继承：

        实例变量：只需要声明新增的变量，若没有，加上“{}”即可，有时“{}”都可以省略
        方法：追加新增的方法，若要重写，则需要在接口中对方法重新声明。
        使用super关键字可以实现调用父类中的方法，即使这个方法在子类中已经被重写了
        super和self不同， 并不确定指向某个对象，所以只能用于调用父类的方法，不能通过super完成赋值，也不能指定返回值类型为super



初始化：

        固定写法：
        -（id）init{

            self=[super init];//一定在第一行调用父类的init方法
            if(self!=nil){//判断父类方法是否调用成功（是有可能失败的），除非父类是NSObject，基本上不可能出错(内存不足呢 ?也不会出错吗？)

            }

            return self;
        }
        初始化失败原因：使用传入的参数，或通过从文件读入变量进行初始化，因为值的类型错误或读取文件失败等原因。
        生成实例对象的方法alloc会把实例对象的变量都初始化为0（除了实例变量isa），所以若子类中心追加的实例变量的初值可以为0，则可以跳过子类的初始化（父类中不行？），
        为了明确是否可省略，最好为初值可以为0的变量加上注释。
        原则上说，初始赋值之后值不再变化的变量和需要显示设定初值的变量，都需要通过带参数的初始化方法来进行初始化。



使用self调用方法：

        在一个方法中调用当前类中定义的方法，可以利用self，但如果存在继承关系，则需要注意，到底哪个方法被调用了(我的self还是我的self)，
        self指的是收到当前消息的实例变量，利用self的特性编程很常见。（Objextive-C编程全解,P39）



使用super调用方法：《Objective-C编程全解 P41》

        super的方法和self完全不同，需要写demo测试，super指的是第一次被继承方法的类的super类？（写4代继承，及隔代继承的demo测试）


局部方法：

        可以只在实现部分中实现，不需要在接口部分中定义，其他模块引用了这个接口文件也无法获得这个方法的定义，一般为一段具备独立功能的方法。
        通常指供内部调用，所以不包含在类的接口中对外公开，但是方法本身还算存在，只要发送了消息，就能够执行。








