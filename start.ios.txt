id obj;

消息表达式 ：[obj msg]// obj 接收者  msg 消息
   
    可作为变量嵌套在语句中，或单独执行返回void
    允许嵌套
    例：element=table[[obj count]]//内层【】 为消息表达式修饰符，外层为数组修饰符，使用【obj count】 的结果作为table[] 数组的下标
    msg位置的参数被称为消息关键字，其末尾有“：”时，表示消息带有参数，“：”后紧跟着的就是实参，可以是变量，也可以是消息表达式
    例：[doc isSameDirectory:[info objectAtIndex:++num]];
    多参消息：
    [方法名 关键字1：a 关键字2：b 关键字3：c]  或 [方法名：a:b:c]
    例：[ manager fixExistsAtPath:dirname isDirectoty:&isdir]; 或[view lineTo:1.1:(y+1.0)];



消息选择器：消息名（选择器，方法）（对应消息表达式中msg位置？）(函数名？参数名？cell=[albumview cellAtRow:i column:j];)

    带有参数的消息选择器要包含“：”
    例：copy 和copy：是两个不同的选择器
    多参情况：cellAtRow: column:
    由多个消息关键字组成的选择器，关键字的顺序不能错，否则是完全不同的选择器



变量：

    同C一样，仅声明不会为变量赋初值
    OC通过向类发送消息来创建一个对象
    例：[类名 alloc]//alloc执行完同C一样为申请到存储空间，仍需调用初始化方法
    Cocoa中的初始化方法通常为init或由init开头的函数。
    例：[[类名 alloc] init] //完整地创建并初始化Cocoa中的某个类//通常嵌套调用alloc和init来生成一个对象
    tip:对象生成后知需调用一次初始化方法，init并没有reset功能,使变量的值恢复初始值需要专用函数，另外，有的类不是用alloc方法而使用其他方法生成对象，
    有的类也可能会返回一个初始化好的对象（OC中哪个系的类会？还是在自己实现中灵活运用？）



类的定义:(interface和implementat是分开的)（OC中的类由接口和实现组成？）

    语法：
    @interface 类名：父类名
    {
        实例变量的定义；
    }
    方法声明；
    @end

    OC中类接口的声明以@interface开头，以@end结尾，所有的OC编译指令都以@ 开头，以区分C中的字符串（关键字？）



方法声明：

    -(id)delegate; // "-"表示是实例方法，返回值使用“（）”括起来
    -(id)cellAtRow:(int)row column:(int) col;//参数的类型指定用“()”括起来放在参数之前，row和col是参数
    -(void)setAutoPlay(BOOL)falg;//无返回值时使用void表示



返回值：

    可以省略方法返回值，编译器默认增加id类型的返回值（不推荐，不清晰）
    tips:在C中省略返回值会默认增加int类型的返回值，但存在争议，有可以能以后会被废除



静态变量：

    在函数或类方法范围外定义的变量，及制定了static的变量，生命周期为从程序开始执行到结束。



根类：

     NSObject是Cocoa环境下的根类（NSProxy听说也是，Objective-C编程全解，19章）



继承：

        实例变量：只需要声明新增的变量，若没有，加上“{}”即可，有时“{}”都可以省略
        方法：追加新增的方法，若要重写，则需要在接口中对方法重新声明。
        使用super关键字可以实现调用父类中的方法，即使这个方法在子类中已经被重写了
        super和self不同， 并不确定指向某个对象，所以只能用于调用父类的方法，不能通过super完成赋值，也不能指定返回值类型为super



初始化：

        固定写法：
        -（id）init{

            self=[super init];//一定在第一行调用父类的init方法
            if(self!=nil){//判断父类方法是否调用成功（是有可能失败的），除非父类是NSObject，基本上不可能出错(内存不足呢 ?也不会出错吗？)

            }

            return self;
        }
        初始化失败原因：使用传入的参数，或通过从文件读入变量进行初始化，因为值的类型错误或读取文件失败等原因。
        生成实例对象的方法alloc会把实例对象的变量都初始化为0（除了实例变量isa），所以若子类中心追加的实例变量的初值可以为0，则可以跳过子类的初始化（父类中不行？），
        为了明确是否可省略，最好为初值可以为0的变量加上注释。
        原则上说，初始赋值之后值不再变化的变量和需要显示设定初值的变量，都需要通过带参数的初始化方法来进行初始化。



使用self调用方法：

        在一个方法中调用当前类中定义的方法，可以利用self，但如果存在继承关系，则需要注意，到底哪个方法被调用了(我的self还是我的self)，
        self指的是收到当前消息的实例变量，利用self的特性编程很常见。（Objextive-C编程全解,P39）



使用super调用方法：《Objective-C编程全解 P41》

        super的方法和self完全不同，需要写demo测试，super指的是第一次被继承方法的类的super类？（写4代继承，及隔代继承的demo测试，最好能跟java一起测试）



局部方法：

        可以只在实现部分中实现，不需要在接口部分中定义，其他模块引用了这个接口文件也无法获得这个方法的定义，一般为一段具备独立功能的方法。
        通常指供内部调用，所以不包含在类的接口中对外公开，但是方法本身还算存在，只要发送了消息，就能够执行。
        只能被定义在局部方法之后的方法调用。
        使用局部方法可以增强程序的可维护性，但在继承的时候可能会出现问题，苹果公司建议为局部方法名添加固定前缀以解决
        例：子类可能会追加一个父类已经实现的局部方法。



指定初始化方法：

        确保所有势力变量都能被初始化的方法，是初始化的核心
        子类的指定初始化方法必须调用父类的指定初始化方法
        如果子类要重写父类中的指定初始化方法，就一定要调用父类的指定初始化方法，而不是调用父类的非指定初始化方法，因为非指定初始化方法内部会调用指定初始化方法，
        造成递归调用。
        OC中没有特殊语法或关键字来标示指定初始化方法，通常通过注释或文档说明，Cocoa API文档中绝大多数类表明了那个方法是指定初始化方法



非指定初始化方法：

        通过封装类调用指定初始化方法的方法



动态绑定：

        在程序执行时才确定对象的属性和需相应的消息
        C语言中只能通过函数指针模拟，但并不优雅，很麻烦

    

静态类型：

        确定的类型，编译时会进行类型检查；id这种通用类型就不会，id类型结合多态可以是程序更灵活，但编译器不会对id类型进行类型检查，使程序更容易出错。
        静态类型除了类型检查，也会在编译时检查接受者是否可以响应收到的消息（方法检查）。
        如果仅适用父类中定义的功能，则变量的类型声明为父类也没有问题，此时无法调用子类（真正实例化的对象）的方法，但可以使用强转后再使用子类的方法。
        如果把父类的实例对象强转成子类，则不会报错，但是强转语句不生效。


编译时类型检查要点：《Objective-C 编程全解》P53
        OC中的多态比java中更丰富（没有继承关系的多态），具体看P54开头



签名：

        消息选择器和参数和返回值的类型的信息结合起来构成签名，用于在运行时标记一个方法，
        接口文件中方法的定义也叫做签名。
        方法签名：
        Cocoa提供了类NSMethodSignature,以面向对象的方式记录方法的参数个数，类型，返回值等信息，这个类的实例也叫做方法签名。

        OC选择器相同的消息，参数和返回值的类型也应该是相同的（java中参数不同即为多态，返回值也可以不同），由其是有继承关系的情况。（P55）
        实际上，Foundation和Application框架内也存在一些选择器相同但签名不同的方法，所以在这一点不要过于追求完美。
        编译时发现签名不一致的情况会发出警告，也可以改方法类型为静态类型来屏蔽警告。
        （那么OC中的多态怎么实现的？继承，覆写，和没有继承关系的同名方法？）

        tips:OC是动态语言，参数的类型是在运行时确定的，不支持根据参数类型不同调用不同函数的重载。
             可以通过动态绑定让同一个消息选择器执行不同的功能实现重载（什么是动态绑定？）



前置声明：

        在定义一个类的时候，需要使用其他数据类型，又不想引入目标类的头文件，（因为可能目标类中又有引入其他类，会加大编译时负担），此时可使用前置声明。
        仅在定义时使用一下类名（若要引用目标文件的具体成员或方法，则必须引入头文件）：
        使用 @class 告知编译器这是个类名，这种写法被叫做类的前置声明。
        class 指令后可一次接多个类，使用“，”分割，使用“；”标示结束，前置声明可以多次声明。

        使用 @class可在只使用类名的情况下提高程序整体的编译速度；
        当出现多个接口出现类的嵌套定义时，如果只是包含对方的头文件，无法解决，则只能通过类的前置声明来解决。



实例变量的访问权限：

        OC 不允许从外部直接访问和修改实例对象的属性，而仅仅可以访问同一个类的其他实例对象的变量，通常会定义专门的方法阿里访问或修改实例变量。
        OC 原则上不允许从对象外直接访问对象的实例变量，但类Ａ的方法中可以直接访问类Ａ中包含self以外的其他实例的实例变量。（虽然原则上不允许，但是能做到？？）
        能不能访问对象的实例变量也需要检查，在编译时完成，因此，只能访问使用静态类型定义的实例对象的内部变量。（？？？）
        对象内外主要指类型？《Objective-C 编程全解》P59有例子，可以明白（看起来就是当前类中可以使用->直接访问其他对象（但是就是当前类的类型（父类也不行））
        的内部实例变量（对象也必须使用当前类型声明，id类型不行））



getter和setter：

        OC中使用属性名作为getter方法的方法名，setter方法有一个void的返回值
        为了封装性更好，降低耦合，即使父子类也应使用这种方法



实例变量的可见性（权限修饰符）：

        private,protected,public,package;具体区别见《Objective-c 编程全解》 P61



